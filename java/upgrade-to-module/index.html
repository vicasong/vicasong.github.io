

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Vica">
  <meta name="keywords" content="">
  
    <meta name="description" content="具2022年初New Relic发布的《Java生态系统状况报告》显示现有超48%的应用程序在生产中使用Java 11（2020年为11.11%），而Java 8则占46.45%。Java 17的排名还不是很高，但它在发布后的几个月里，已经超过了Java 6、Java 10和Java 16版本的占比。升级到新版本的Java已经是大势所趋，为此本文着重描述如何从Java8升级到Java模块系统（Ja">
<meta property="og:type" content="article">
<meta property="og:title" content="升级到Java模块系统">
<meta property="og:url" content="https://vicasong.github.io/java/upgrade-to-module/">
<meta property="og:site_name" content="VicaSong">
<meta property="og:description" content="具2022年初New Relic发布的《Java生态系统状况报告》显示现有超48%的应用程序在生产中使用Java 11（2020年为11.11%），而Java 8则占46.45%。Java 17的排名还不是很高，但它在发布后的几个月里，已经超过了Java 6、Java 10和Java 16版本的占比。升级到新版本的Java已经是大势所趋，为此本文着重描述如何从Java8升级到Java模块系统（Ja">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-09T01:52:06.000Z">
<meta property="article:modified_time" content="2024-01-08T06:10:56.510Z">
<meta property="article:author" content="Vica">
<meta property="article:tag" content="java">
<meta property="article:tag" content="modularity">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>升级到Java模块系统 - VicaSong</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vicasong.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>VicaSong</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="升级到Java模块系统"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-09 09:52" pubdate>
          2022年5月9日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          136 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">升级到Java模块系统</h1>
            
            
              <div class="markdown-body">
                
                <p>具2022年初New Relic发布的《Java生态系统状况报告》显示现有超48%的应用程序在生产中使用Java 11（2020年为11.11%），而Java 8则占46.45%。Java 17的排名还不是很高，但它在发布后的几个月里，已经超过了Java 6、Java 10和Java 16版本的占比。升级到新版本的Java已经是大势所趋，为此本文着重描述如何从Java8升级到Java模块系统（Java9+）。</p>
<span id="more"></span>

<h1 id="为何要升级到模块系统"><a href="#为何要升级到模块系统" class="headerlink" title="为何要升级到模块系统"></a>为何要升级到模块系统</h1><h2 id="时代背景"><a href="#时代背景" class="headerlink" title="时代背景"></a>时代背景</h2><p>如摘要所述，Java8及以下版本已经逐渐失去大半“Java江山”。  </p>
<p>当然这个理由未必能让你感兴趣做出升级，请继续往下看。</p>
<h2 id="现如今的问题"><a href="#现如今的问题" class="headerlink" title="现如今的问题"></a>现如今的问题</h2><h3 id="类路径地狱"><a href="#类路径地狱" class="headerlink" title="类路径地狱"></a>类路径地狱</h3><p>Java运行时使用类路径（classpath）来查找类，这可以说是使用Java的常识，请看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">classPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">printLines</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot;\n&quot;</span>,classPath.split(<span class="hljs-string">&quot;;&quot;</span>));<br>System.out.println(printLines);<br></code></pre></td></tr></table></figure>

<p>这段代码很简单，用来输出打印运行当前Java程序的类路径，即使是一个简单的应用，类路径也会冗长复杂。</p>
<figure class="highlight text"><figcaption><span>console.out</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">C:\Users\xx\IdeaProjects\example\build\classes\java\main<br>C:\Users\xx\IdeaProjects\example\build\resources\main<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\com.google.guava\guava\31.1-jre\60458f877d055d0c9114d9e1a2efb737b4bc282c\guava-31.1-jre.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\org.hibernate.validator\hibernate-validator\7.0.4.Final\36c91ad2987af9c5dd19eb4f011d9d294ac1721e\hibernate-validator-7.0.4.Final.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\com.google.guava\failureaccess\1.0.1\1dcf1de382a0bf95a3d8b0849546c88bac1292c9\failureaccess-1.0.1.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\com.google.guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\b421526c5f297295adef1c886e5246c39d4ac629\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\com.google.code.findbugs\jsr305\3.0.2\25ea2e8b0c338a877313bd4672d3fe056ea78f0d\jsr305-3.0.2.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\org.checkerframework\checker-qual\3.12.0\d5692f0526415fcc6de94bb5bfbd3afd9dd3b3e5\checker-qual-3.12.0.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\com.google.errorprone\error_prone_annotations\2.11.0\c5a0ace696d3f8b1c1d8cc036d8c03cc0cbe6b69\error_prone_annotations-2.11.0.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\com.google.j2objc\j2objc-annotations\1.3\ba035118bc8bac37d7eff77700720999acd9986d\j2objc-annotations-1.3.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\jakarta.validation\jakarta.validation-api\3.0.0\8c8eecc40da64037d7731356511c568d466f8480\jakarta.validation-api-3.0.0.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\org.jboss.logging\jboss-logging\3.4.1.Final\40fd4d696c55793e996d1ff3c475833f836c2498\jboss-logging-3.4.1.Final.jar<br>C:\Users\xx\.gradle\caches\modules-2\files-2.1\com.fasterxml\classmate\1.5.1\3fe0bed568c62df5e89f4f174c101eab25345b6c\classmate-1.5.1.jar<br></code></pre></td></tr></table></figure>


<p>所有类按照<code>-classpath</code>参数定义的顺序排列成一个平面列表。当JVM加载一个类时，按照顺序读取类路径，找到所需的类，然后结束搜索就并加载类。如果在类路径中没有找到所需的类又会得到一个运行时异常，由于类会延迟加载，因此在用户看来应用程序会在使用中莫名其妙的突然出错。而当类路径上有重复类时，则会出现更为隐蔽的问题，一般来说，当类路径包含两个具有相同（完全限定名称）的类时，即使它们不相关，也只有一个会被成功加载。</p>
<h3 id="封装依赖"><a href="#封装依赖" class="headerlink" title="封装依赖"></a>封装依赖</h3><p>Java提供的访问修饰符（比如<code>private</code>、<code>protected</code>或<code>public</code>等），可以实现类的封装。例如将一个类置为<code>protected</code>，那么就可以防止其他类访问该类，除非这些类与该类位于相同的包中。但这样做会产生一个问题：如果想从当前库的另一个包访问该类，同时仍然防止其他类使用该类，那么应该怎么做呢？事实是无法做到。当然，可以让类公开，但公开意味着对所有库公开，也就意味着没有封装。我们没有办法隐藏这样的实现包。   </p>
<p>例如，<code>Guava</code>中的<code>com.google.common.base.internal.Finalizer</code>，它并不是官方API的一部分，而是一个公共类，其他<code>Guava</code>包可以使用<code>Finalizer</code>，这也意味着无法阻止任意使用者使用诸如<code>Finalizer</code>之类的类。  </p>
<p>对于Java平台的内部类来说也存在同样的情况。诸如<code>sun.misc</code>之类的包经常被应用程序代码所访问，虽然相关文档严重警告它们是不受支持的API，不应该使用。例如：<code>sun.misc.BASE64Encoder</code>之类的工具类仍然在应用程序代码中被使用。缺乏封装性迫使这些类被认为是“半公共”API。</p>
<h2 id="模块化的优势"><a href="#模块化的优势" class="headerlink" title="模块化的优势"></a>模块化的优势</h2><p>Java一直是构建大型应用程序的主流语言之一，且Java生态系统中有许多库，在此背景下构建的系统往往超出我们理解和有效开发范围，为什么这么说呢？我们无法理清各部分代码块之间的关系，在使用繁多的归档文件（Java Archive, JAR）时更加突出，模块化能很好的管理和减少这种复杂性，而从Java9开始引入了模块系统，且Java本身也已经被模块化。</p>
<h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><p>模块化（modularization）是指将系统分解成独立且相互关联的模块的行为。</p>
<p>模块（module）是包含代码的可识别组件，使用元数据来描述模块及与其他模块的关系。</p>
<p>在理想情况下，模块从编译时到运行时都是可识别的，关系是清晰明确的。一个应用程序由多个模块协作组成。</p>
<p><strong>强封装</strong> </p>
<p>模块能对其他模块隐藏其部分代码。这样就可以清晰的区分公开代码和被视为内部实现细节的隐藏代码，从而防止模块之间发生意外或不必要的耦合，即其他模块无法使用该模块被封装的内容。</p>
<p>其实封装依赖在Java模块系统出现之前就早有诟病，库的开发者即使明确将实现代码放在<code>xx.internal</code>之类意味不公开的内部实现包下，但谁会在意呢，只要有类可以用，就有人会使用它，导致库的更新对使用者是破坏性的。</p>
<p><strong>公共接口</strong></p>
<p>模块要一起工作，并不是所有的东西都会封装。其中未封装的代码应该是模块的公共API部分。由于其他模块可以访问这部分公共代码，须谨慎对其进行管理。对公开代码进行更改则可能会导致依赖于它的其他模块无法正常使用，因此，模块对其他模块的公开部分应该定义良好且稳定。</p>
<p><strong>显式依赖</strong></p>
<p>模块如果需要使用其他模块，则模块之间构成依赖关系，这些依赖关系必须是模块定义的一部分。显式依赖可以构建出一个模块图：节点表示模块，而边缘表示模块之间的依赖关系。<br>通过模块图可以清楚的了解应用程序和运行应用所需各个模块间的关系。它为模块的可靠配置提供了基础。</p>
<p>Java代码中虽然使用了显式的<code>import</code>语句，但从严格意义上讲，这些依赖关系是编译时结构，一旦代码被打包到<code>JAR</code>文件，就无法确定哪些文件包含运行所需的类。</p>
<h3 id="模块化带来的好处"><a href="#模块化带来的好处" class="headerlink" title="模块化带来的好处"></a>模块化带来的好处</h3><p><strong>明确的依赖</strong>  </p>
<p>在编译或运行代码之前，模块系统会检查模块是否满足所有依赖关系，从而导致更少的运行时错误。</p>
<p><strong>强封装</strong>  </p>
<p>模块明确向其他模块的公开内容，阻止对未公开的内部实现细节的意外依赖。</p>
<p><strong>安全</strong></p>
<p>在JVM的最深层次上执行强封装，减少Java运行时的攻击面，同时无法获得对敏感内部类的反射访问。</p>
<p><strong>可扩展</strong></p>
<p>显式定义的模块边界能够让开发团队并行工作，创建可维护的代码库。</p>
<p><strong>优化</strong></p>
<p>由于模块系统清楚的知道模块之间的关系，包括Java平台模块，因此在JVM启动期间不需要考虑其他未使用的代码。同时，也可以为此创建模块分发的最小配置（例如应用镜像）。在模块出现之前，没有可用的显式依赖信息，一个类可以引用类路径中任何其他类。</p>
<h1 id="迁移到模块系统"><a href="#迁移到模块系统" class="headerlink" title="迁移到模块系统"></a>迁移到模块系统</h1><p>根据系统业务及可用资源充分评估是否合适进行模块化，我们的最终目的是模块化，但现实并非如此，为此针对不同系统可选用不同的升级方案。  </p>
<p>以下为模块化所需的三个步骤，但同时也是模块化之路的三种不同方案即三种目标。</p>
<h2 id="升级Java版本"><a href="#升级Java版本" class="headerlink" title="升级Java版本"></a>升级Java版本</h2><p>向后兼容性一直是Java的主要目标。当不需要使用模块系统时，为什么还要迁移到Java9+ 呢？升级将带来新的API、工具和性能改进（<a href="/java/upgrade-to-java17/" title="从Java8升级到Java17">从Java8升级到Java17</a>）。  </p>
<h3 id="切换Java"><a href="#切换Java" class="headerlink" title="切换Java"></a>切换Java</h3><p>一般的，如果应用程序和依赖只使用了JDK认可的API，那么直接切换到新版本Java上编译运行是不会出现问题的。但这是理想情况，现在的Java本身已经实现了模块化，无论应用程序是否模块化。</p>
<p>应用程序可以依旧使用类路径（<code>-classpath</code>），而所有类路径上的代码都会被当做<em>未命名模块</em>（UnNamed Module）。  而Java模块使用模块路径（<code>--module-path</code>），由于Java平台本身已经模块化，<code>java/javac</code>命令会默认使用JDK模块路径。</p>
<p>我们在Java<code>jmods</code>目录可以清楚的看到平台的模块文件：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs text">java.base.jmod<br>java.compiler.jmod<br>java.datatransfer.jmod<br>java.desktop.jmod<br>java.instrument.jmod<br>java.logging.jmod<br>java.management.jmod<br>java.management.rmi.jmod<br>java.naming.jmod<br>java.net.http.jmod<br>java.prefs.jmod<br>java.rmi.jmod<br>java.scripting.jmod<br>java.se.jmod<br>java.security.jgss.jmod<br>java.security.sasl.jmod<br>java.smartcardio.jmod<br>java.sql.jmod<br>java.sql.rowset.jmod<br>java.transaction.xa.jmod<br>java.xml.crypto.jmod<br>java.xml.jmod<br>jdk.accessibility.jmod<br>jdk.aot.jmod<br>jdk.attach.jmod<br>jdk.charsets.jmod<br>jdk.compiler.jmod<br>jdk.crypto.cryptoki.jmod<br>jdk.crypto.ec.jmod<br>jdk.crypto.mscapi.jmod<br>jdk.dynalink.jmod<br>jdk.editpad.jmod<br>jdk.hotspot.agent.jmod<br>jdk.httpserver.jmod<br>jdk.internal.ed.jmod<br>jdk.internal.jvmstat.jmod<br>jdk.internal.le.jmod<br>jdk.internal.opt.jmod<br>jdk.internal.vm.ci.jmod<br>jdk.internal.vm.compiler.jmod<br>jdk.internal.vm.compiler.management.jmod<br>jdk.jartool.jmod<br>jdk.javadoc.jmod<br>jdk.jcmd.jmod<br>jdk.jconsole.jmod<br>jdk.jdeps.jmod<br>jdk.jdi.jmod<br>jdk.jdwp.agent.jmod<br>jdk.jfr.jmod<br>jdk.jlink.jmod<br>jdk.jshell.jmod<br>jdk.jsobject.jmod<br>jdk.jstatd.jmod<br>jdk.localedata.jmod<br>jdk.management.agent.jmod<br>jdk.management.jfr.jmod<br>jdk.management.jmod<br>jdk.naming.dns.jmod<br>jdk.naming.rmi.jmod<br>jdk.net.jmod<br>jdk.pack.jmod<br>jdk.rmic.jmod<br>jdk.scripting.nashorn.jmod<br>jdk.scripting.nashorn.shell.jmod<br>jdk.sctp.jmod<br>jdk.security.auth.jmod<br>jdk.security.jgss.jmod<br>jdk.unsupported.desktop.jmod<br>jdk.unsupported.jmod<br>jdk.xml.dom.jmod<br>jdk.zipfs.jmod <br></code></pre></td></tr></table></figure>


<h4 id="深度反射问题"><a href="#深度反射问题" class="headerlink" title="深度反射问题"></a>深度反射问题</h4><p>当使用模块时，默认情况下JDK不允许访问封装的包以及深度反射（指使用反射技术访问类的非公共代码）其他模块（包括平台模块）中的代码。在模块化系统之前，平台内部类的滥用已经成为许多安全问题的源头，并且阻碍了API的发展。而一些常用的库确实是这么做的，例如<code>javassist</code>库试图调用<code>java.lang.Class</code>上的<code>defineClass</code>方法，那么此时会引起如下错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">java.lang.reflect.InaccessibleObjectException: Unable to make protected final<br>    java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],<br>                                        int,int,java.security.ProtectionDomain)<br>  throws java.lang.ClassFormatError accessible: module java.base does not<br>  &quot;opens java.lang&quot; to unnamed module @0x7b3300e5<br></code></pre></td></tr></table></figure>


<p>如上描述，当前未命名模块不能访问平台模块<code>java.base</code>的<code>protected defineClass</code>方法，因为平台模块<code>java.base</code>未将<code>java.lang</code>包对此未命名模块开放。  </p>
<p>此处引入了一个概念，即开放包（open package）。同类的概念还有导出包（export package）、开放模块（open module）等。</p>
<p><strong>导出包</strong></p>
<p>导出包指模块声明自身的公共API所在的包，指示了模块对外公开的内容，而未被导出的其他包即为封装包，其他模块可以直接访问该模块的导出部分（公共部分）。</p>
<p><strong>开放包和开放模块</strong></p>
<p>许多库都希望可以进行深度反射。但由于强封装性，即使导出了实现类所在的包，也会禁止其对非公共部分进行深度反射。     </p>
<p>因此，开放包可以向其他模块公开包中封装的资源，允许对指定包内的代码进行深度反射，同理，开放模块则将开放范围延展到整个模块，开放整个模块看似有点不妥，但当不能确定在运行时库或框架使用什么类型时，这种做法是很方便的。 </p>
<p>Java9+添加了两个反射对象的新方法：<code>canAccess</code>和<code>trySetAccessible</code>，考虑到深度反射并不总是被允许，使用这些方法可以避免调用<code>setAccessible</code>时抛出异常。   </p>
<p>我们可以仅开放允许深度反射的包，而不导出它。这样对于框架来说，开放包是可以自由访问的，但从开发人员的角度看，这部分未导出的开放包仍被强封装。  </p>
<p>回到上面我们遇到的错误，未命名模块无法通过深度反射访问平台模块非公共的部分，这里需要开放平台模块<code>java.base</code>的<code>java.lang</code>包，通常在模块描述文件中使用<code>opens xxx</code>子句来开放一个包，但很显然我们无法修改平台模块。</p>
<p>此时可以通过命令行对那些无法控制的模块描述做出补充：   </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java --add-opens java.base/java.lang=ALL-UNNAMED<br></code></pre></td></tr></table></figure>  


<p>其中，<code>java.base/java.lang</code>是授权访问的<code>模块/包</code>格式，最后一个参数是获取访问权限的模块。因为代码仍然在类路径中，所以使用了<code>ALL-UNNAMED</code>，它表示类路径（未命名模块）。现在，这个包是开放的，所以深度反射不再是非法的。同理，我们可以使用<code>--add-exports</code>来强制导出包，但这些都只是一个解决方法。</p>
<h4 id="封装访问"><a href="#封装访问" class="headerlink" title="封装访问"></a>封装访问</h4><p>JDK包含许多私有的内部API，这些API应该仅被JDK所使用。从早期开始，这一规定就已被清楚地记载下来。比如<code>sun.*</code>和<code>jdk.internal.*</code>包。而当你的程序或程序依赖的库任然在使用这些类型时，将无法通过编译。</p>
<p>例如早期Java程序使用<code>sun.security.x509</code>包中的类型，切换到更高版本的Java时则会遇到如下的编译错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text"> error: package sun.security.x509 is not visible<br>import sun.security.x509.X500Name;<br>                   ^<br>  (package sun.security.x509 is declared in module java.base, which does not<br>   export it to the unnamed module)<br></code></pre></td></tr></table></figure>  


<p>如果这部分代码可控，那么涉及访问封装类型时，应该对其进行修改，用公共类型替代。而当所使用的库使用了封装类型且我们自己无法修复这个问题，同上也可以使用命令行标志在编译时打破封装。<br>此处可使用<code>--add-exports &lt;module&gt;/&lt;package&gt;=&lt;targetmodule&gt;</code>这样的语法导出封装的包，但这只是一种零时解决办法。</p>
<h4 id="命令行过长"><a href="#命令行过长" class="headerlink" title="命令行过长"></a>命令行过长</h4><p>一些操作系统限制了可执行命令行的长度。当在迁移期间需要添加许多标志时，可能会触发这些限制。此时的替代做法是使用一个文件将所有的命令行参数提供给<code>java/javac</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">java @arguments.txt</span><br></code></pre></td></tr></table></figure>  

<p>参数文件必须包含所有必要的命令行标志。文件中的每一行都包含一个选项。例如，<code>arguments.txt</code>可以包含以下内容：</p>
<figure class="highlight text"><figcaption><span>arguments.txt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">-cp application.jar:javassist.jar<br>--add-opens java.base/java.lang=ALL-UNNAMED<br>--add-exports java.base/sun.security.x509=ALL-UNNAMED<br>-jar application.jar<br></code></pre></td></tr></table></figure>  


<h4 id="移除的类型"><a href="#移除的类型" class="headerlink" title="移除的类型"></a>移除的类型</h4><p>随着Java的升级，其中一些内部类会被移除（依赖内部实现类是不规范的）。例如在<em>Java 9</em>中删除的内部类是<code>sun.misc.BASE64Encoder</code>，而在这之前的<code>Java 8</code>中引入了其公开替代实现<code>java.util.Base64</code>。</p>
<p>但我们并总是清楚这些替代实现，而JDK附带了一个工具<code>jdeps</code>来帮助我们。<code>jdeps</code>可以找到被删除或封装的JDK类型，并建议替换，其工作基于类文件（.class文件）而非源码文件，例如对在Java 8环境下编译且使用了<code>sun.misc.BASE64Decoder</code>的类进行解析：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">$ jdeps -jdkinternals removed/RemovedTypes.class<br><br>RemovedTypes.class -&gt; JDK removed internal API<br>   removed.RemovedTypes -&gt; sun.misc.BASE64Decoder<br>   JDK internal API (JDK removed internal API)<br><br>Warning: JDK internal APIs are unsupported and private to JDK implementation<br>that are subject to be removed or changed incompatibly and could<br>break your application.<br>Please modify your code to eliminate dependence on any JDK internal APIs.<br>For the most recent update on JDK internal API replacements, please check:<br>https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool<br><br>JDK Internal API                         Suggested Replacement<br>----------------                         ---------------------<br>sun.misc.BASE64Decoder                   Use java.util.Base64 @since 1.8<br></code></pre></td></tr></table></figure>  


<h4 id="缺失模块"><a href="#缺失模块" class="headerlink" title="缺失模块"></a>缺失模块</h4><p>JDK中Java SE和Java EE之间的重叠一直令人困惑。Java EE应用程序服务器通常提供了API的自定义实现。简单地讲，是通过将替代实现放在类路径上，覆盖默认的JDK版本来完成的。而在Java模块系统不允许多个模块提供相同的包。如果在类路径中找到重复的包（在未命名的模块中），则会将其忽略。在任何情况下，若Java SE和应用程序服务器都提供<code>java.xml.bind</code>包，则不会实现预期的行为，为了避免出现该问题，在<strong>基于类路径</strong>的场景中，默认情况下不会解析这些模块。</p>
<p>例如：  </p>
<figure class="highlight java"><figcaption><span>JaxbExample.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> example;<br><br><span class="hljs-keyword">import</span> javax.xml.bind.JAXBContext;<br><span class="hljs-keyword">import</span> javax.xml.bind.JAXBException;<br><span class="hljs-keyword">import</span> javax.xml.bind.Marshaller;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JaxbExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>();<br>      book.setTitle(<span class="hljs-string">&quot;Java 9 Modularity&quot;</span>);<br><br>      <span class="hljs-type">JAXBContext</span> <span class="hljs-variable">jaxbContext</span> <span class="hljs-operator">=</span> JAXBContext.newInstance(Book.class);<br>      <span class="hljs-type">Marshaller</span> <span class="hljs-variable">jaxbMarshaller</span> <span class="hljs-operator">=</span> jaxbContext.createMarshaller();<br><br>      jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <span class="hljs-literal">true</span>);<br><br>      jaxbMarshaller.marshal(book, System.out);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 

<p>上述代码在Java 8可以正常使用，但在新版本Java进行编译就会出现问题：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">example/JaxbExample.java:3: error: package javax.xml.bind is not visible<br>import javax.xml.bind.JAXBContext;<br>               ^<br> (package javax.xml.bind is declared in module java.xml.bind, which is not<br>   in the module graph)<br>example/JaxbExample.java:4: error: package javax.xml.bind is not visible<br>import javax.xml.bind.JAXBException;<br>               ^<br> (package javax.xml.bind is declared in module java.xml.bind, which is not<br>   in the module graph)<br>example/JaxbExample.java:5: error: package javax.xml.bind is not visible<br>import javax.xml.bind.Marshaller;<br>               ^<br> (package javax.xml.bind is declared in module java.xml.bind, which is not<br>   in the module graph)<br>3 errors<br></code></pre></td></tr></table></figure>    


<p>为了解决这个问题，则需要添加<code>--add-modules java.xml.bind</code>选项到命令行<code>java</code>或<code>javac</code>的调用中以添加解析模块<code>java.xml.bind</code>。当然这些模块会随着版本升级逐渐被删除，你可以通过将这些技术的Jar文件添加到类路径来避免。</p>
<h2 id="移动到模块路径"><a href="#移动到模块路径" class="headerlink" title="移动到模块路径"></a>移动到模块路径</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>终于，我们可以开始着手当前迁移项目（此处的项目表示一个单独的代码模块）的模块化改造了，这部分内容简要概括一下：</p>
<p><strong>模块描述</strong>  </p>
<p>我们只需要在项目根包（<code>/</code>）下创建一个名为<code>module-info.java</code>的模块描述文件即可将当前项目转换为模块，模块描述内容很简单，例如：</p>
<figure class="highlight java"><figcaption><span>module-info.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> me.example.test &#123;                  <span class="hljs-comment">// (1)</span><br>    <span class="hljs-keyword">requires</span> java.sql;                    <span class="hljs-comment">// (2)</span><br>    <span class="hljs-keyword">exports</span> me.example.api;               <span class="hljs-comment">// (3)</span><br>    opens me.example.entity;              <span class="hljs-comment">// (4)</span><br>    uses java.sql.Driver;                 <span class="hljs-comment">// (5)</span><br>    provides me.example.api.DemoService   <span class="hljs-comment">// (6)</span><br>            with me.example.api.impl.DemoServiceFactory;<br>&#125;<br></code></pre></td></tr></table></figure> 


<p>解释一下上面所用的描述符：  </p>
<ul>
<li>(1) 指定了当前模块的唯一命名<br>格式为 <code>[open] module &lt;Module Name&gt;</code>    </li>
<li>(2)<code>requires</code> 子句指定了模块显式依赖<br>只有指定为显式依赖，才可以在代码中直接使用依赖模块的导出内容，格式为<code>requires &lt;Module Name&gt;</code>    </li>
<li>(3)<code>exports</code> 子句指定模块导出的公共包<br>即对外公开的API，非导出部分都将被封装，格式为<code>exports &lt;Package Name&gt; [to &lt;Module Name&gt;]</code>    </li>
<li>(4)<code>opens</code> 子句指定模块的开放包<br>即允许深度反射的部分，格式为 <code>opens &lt;Package Name&gt; [to &lt;Module Name&gt;]</code>，例如：一般考虑到对ROM框架的支持会开放数据实体包    </li>
<li>(5)<code>uses</code> 子句表明了模块可以使用实现了指定接口的服务<br>例如上所描述的<code>java.sql.Driver</code>，该子句用于指定服务依赖关系（可选依赖）    </li>
<li>(5)<code>provides</code> 子句表明该模块可以对外提供实现了指定接口的服务<br>例如上所描述的提供实现了<code>me.example.api.DemoService</code>的服务</li>
</ul>
<p>在上面的示例中提到了一个新概念：服务依赖。<br>我们先考虑一个常见的场景：模块A对外导出了公共API <code>DemoService</code>，同时会有一个封装的默认实现<code>DefaultDemoServiceImpl</code>，但实现是被封装的，为此需要在公开部分添加一个能获取该默认实现的方法，例如使用一个工厂，很显然模块A的公共API多了一个用于获取默认实现的工厂API，且我们很难再对这个公共工厂做出修改，API不应与其实现紧密耦合。    </p>
<p>我们现在可以通过Java模块系统中的服务机制进行解耦。使用服务，可以真正地共享公共接口，并将实现代码强封装到未导出的包中。而是否使用模块系统中的服务是完全可选的，因此服务依赖也就成为可选依赖。  </p>
<p>早在模块系统出现之前，Java中就已经存在一个类似的设计———— <code>ServiceLoader</code>，也就是所谓的SPI（Service Provider Interface）。如下所示，我们使用模块系统中的服务获取<code>java.sql.Driver</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ServiceLoader;<br><span class="hljs-keyword">import</span> java.sql.Driver;<br><span class="hljs-comment">// ...</span><br>ServiceLoader&lt;Driver&gt; driverLoader = ServiceLoader.load(Driver.class);<br>Optional&lt;ServiceLoader.Provider&lt;Driver&gt;&gt; driverOptional = driverLoader.stream().findFirst();<br><span class="hljs-keyword">if</span> (driverOptional.isPresent()) &#123;<br>   <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> driverOptional.get();<br>   <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>   

<p>由于我们在模块描述中已经表明了可选依赖<code>uses java.sql.Driver</code>，所以，一旦在模块路径发现有对应服务的提供者，就会创建于本模块的服务依赖，例如在模块路径中添加了<code>java.sql.Driver</code>服务的提供模块如Mysql、Oracle等（前提是这些模块在描述<code>provides</code>子句中声明了其对外提供服务），我们就可以通过<code>ServiceLoader</code>获取（延迟加载）这些实现，同时还能识别这些实现（通过检查<code>ServiceLoader.Provider</code>对象）。基于篇幅，这部分简单介绍就到此为止。</p>
<h3 id="自动模块"><a href="#自动模块" class="headerlink" title="自动模块"></a>自动模块</h3><p>由于我们的项目已经模块化，成为一个命名模块，此时项目就无法再访问类路径上的内容了（未命名模块）。为此需要将项目直接依赖的库从类路径移到模块路径。</p>
<p>尽管一些库本身并未模块化，其仍然可以作为模块在模块路径中使用，而这些库在模块路径上时会被转化为自动模块（Automatic Module）。截至目前，我们知道了Java模块系统提供了三种类型的模块：未命名模块、自动模块和命名模块。让我们区分一下这些模块类型的特点：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>生成规则</th>
<th>命名</th>
<th>依赖关系</th>
<th>公开导出</th>
<th>开放封装</th>
<th>拆分包</th>
<th>特殊</th>
</tr>
</thead>
<tbody><tr>
<td>未命名模块</td>
<td>在类路径上</td>
<td>ALL-UNNAMED</td>
<td>读取所有其他模块</td>
<td>所有包</td>
<td>所有包</td>
<td>允许</td>
<td>不允许被命名模块读取</td>
</tr>
<tr>
<td>自动模块</td>
<td>不包含<code>module-info.class</code>模块描述，且在模块路径上</td>
<td>META-INF&#x2F;MANIFEST.MF中指定或文件名转换</td>
<td>读取所有其他自动模块和未命名模块</td>
<td>所有包</td>
<td>所有包</td>
<td>不允许</td>
<td>依赖将被传递</td>
</tr>
<tr>
<td>命名模块</td>
<td>包含<code>module-info.class</code>模块描述，且在模块路径上</td>
<td>模块描述指定</td>
<td>模块描述指定（requires）</td>
<td>模块描述指定（exports）</td>
<td>模块描述指定（opens）</td>
<td>不允许</td>
<td>不允许读取未命名模块</td>
</tr>
</tbody></table>
<blockquote>
<p>拆分包：指不同模块或库拥有相同限定名的包，就好像一个包的内容被拆分到了不同的模块或库中。在Java引入模块系统前（Java9+）是允许拆分包存在的。</p>
</blockquote>
<p>自动模块的名称可以通过<code>META-INF/MANIFEST.MF</code>的<code>Automatic-Module-Name</code>节点属性指定，这是库作者对模块化最低程度的支持。而当未指定自动模块名称时，自动模块的名称则由库文件名决定：<br><em>使用点（.）替换文件名中的非字母数字字符（[^A-Za-z0-9]），剔除重复的点（.）</em>，例如：<code>jackson-databind-1.0.0.jar</code>将成为自动模块<code>jackson.databind</code>。</p>
<p>解析模块图是根据一组给定的根模块计算出来的，在自动模块的情况下，模块解析会产生混乱。当模块未指定自动模块显式依赖时，自动模块和其传递依赖（所有其他自动模块）就不会被解析，同时，使用<code>--add-modules</code>手动添加依赖项非常耗时。而当应用程序<code>requires</code>一个自动模块时，所有自动模块都会被自动解析，这样一来，就可能导致未使用的自动模块也被解析（占用不必要的资源），所以请保持模块路径尽可能“干净”，仅将和应用有直接显式依赖关系的自动模块放在模块路径上。</p>
<p>但在众多的库中，我们很难清楚其模块的引用关系，此时可以使用<code>jdeps</code>工具，在上面我们已经使用过该工具了。现在我们使用该工具进行库的依赖分析，对于如下应用：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">├── lib<br>│   ├── jackson-annotations-2.8.8.jar<br>│   ├── jackson-core-2.8.8.jar<br>│   └── jackson-databind-2.8.8.jar<br>└── out<br>    └── demo<br>        ├── Book.class<br>        └── Main.class<br></code></pre></td></tr></table></figure>   

<p>使用命令分析类路径编译的应用： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">jdeps -recursive -summary -<span class="hljs-built_in">cp</span> lib/*.jar out</span><br><br>jackson-annotations-2.8.8.jar -&gt; java.base<br>jackson-core-2.8.8.jar -&gt; java.base<br>jackson-databind-2.8.8.jar -&gt; lib/jackson-annotations-2.8.8.jar<br>jackson-databind-2.8.8.jar -&gt; lib/jackson-core-2.8.8.jar<br>jackson-databind-2.8.8.jar -&gt; java.base<br>jackson-databind-2.8.8.jar -&gt; java.desktop<br>jackson-databind-2.8.8.jar -&gt; java.logging<br>jackson-databind-2.8.8.jar -&gt; java.sql<br>jackson-databind-2.8.8.jar -&gt; java.xml<br>out -&gt; lib/jackson-databind-2.8.8.jar<br>out -&gt; java.base<br></code></pre></td></tr></table></figure>  


<p>根据上面的输出已经可以得出结论，为了将代码迁移到模块，需要使<code>jackson-databind</code>成为自动模块。同时<code>jackson-databind</code>依赖于<code>jackson-core</code>和<code>jackson-annotations</code>，所以这些库可以停留在类路径或移动到模块路径。如果想知道为什么存在依赖关系，可以省略上述命令中的<code>-summary</code>参数打印更多的细节，以及准确显示哪些包需要哪些其他包，如果信息还不够详细，可以添加参数<code>-verbose:class</code>以打印类级别依赖关系。</p>
<p>未命名模块本身只能通过自动模块读取，迁移过程并非一蹴而就，往往会存在部分类路径和模块路径混合使用的情况。</p>
<h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p><strong>反射加载</strong></p>
<p>迁移到模块时应该特别注意那些使用反射加载的代码。常见的例子比如加载JDBC驱动可能会使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> demo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;org.hsqldb.jdbcDriver&quot;</span>);<br>    System.out.println(clazz.getName());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  

<p>此时我们的模块还没有指定具体的显式依赖描述，运行代码时将会抛出一个异常：<code>java.lang.ClassNotFoundException: org.hsqldb.jdbcDriver</code>，因为<code>hsqldb</code>自动模块未被加载。当然我们可以在我们的模块描述中添加自动模块的显式依赖，但这样做很糟糕，我们不应该依赖具体的实现，为了使应用能正常启动，我们可以在启动命令中临时添加参数<code>--add-modules hsqldb</code>。</p>
<p>现在驱动可以加载了，但又会引起一个异常，由于我们加载的驱动依赖于<code>java.sql.Driver</code>（<code>java.sql</code>模块），而我们的模块描述中并未对其进行依赖声明，所以我们修改模块的描述，添加<code>requires java.sql;</code>子句。 此时如果删除启动命令中的<code>--add-modules hsqldb</code>参数，应用仍能正常启动，这是为什么？</p>
<p>我们显式依赖了模块<code>java.sql</code>，而该模块定义了<code>java.sql.Driver</code>服务接口，同时<code>uses</code>该服务，而<code>hsqldb</code>的库提供了一个这样的服务实现，它通过旧的SPI方式（META-INF&#x2F;services中使用文件注册服务）提供了服务实现，所以基于服务绑定，<code>hsqldb</code>的自动模块会从模块路径上被解析。</p>
<p><strong>拆分包</strong> </p>
<p>拆分包意味着两个模块包含相同的包，Java模块系统不允许拆分包。因此，从类路径到模块路径可能会遇到拆分包的问题。</p>
<p>拆分包始终是不正常的，而当使用解析可传递依赖项的构建工具（如Maven等）时，很容易出现同一个库的多个版本，当Java模块系统检测到一个包存在于模块路径上的多个模块中时，就会拒绝启动。如果在迁移时遇到了拆分包问题，无论如何都是无法绕过的。即使从用户角度来看基于类路径的应用程序可以正确工作，你也最终需要处理这些问题。</p>
<p><strong>Idea启动问题</strong> </p>
<p>截至文档发布，我使用的Idea版本为<code>2021.2.1</code>，其存在一些模块化资源打包的Bug，例如：</p>
<p>Idea将<code>resources</code>资源编译输出到<code>build/resources/main</code>目录下，而模块目录为<code>build/classes/java/main</code>，此时就会出现资源找不到的问题，可以通过添加<code>VM Options</code>的<code>--patch-module</code>参数选项，如：<code>--patch-module me.example.test=example/build/resources/main</code>将资源目录通过<code>patch</code>的方式追加到指定模块。</p>
<h2 id="模块化改造"><a href="#模块化改造" class="headerlink" title="模块化改造"></a>模块化改造</h2><p>虽然项目已经通过添加模块描述文件实现了模块化，但并不是一个优秀的模块，我们还需要对项目的包进行调整，仅导出我们认为需要导出的包，同时使用服务依赖进行对具体实现的解耦，如果有提供API的实现，则需要描述服务提供<code>provides</code>。</p>
<p>同时，相应的自动模块应该使用其模块化的版本替代。</p>
<p>而资源也是封装在模块中的，推荐的做法是使用服务提供实现各模块间资源共享。</p>
<blockquote>
<p>文献参考：《Java 9 Modularity》</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/">#java</a>
      
        <a href="/tags/modularity/">#modularity</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>升级到Java模块系统</div>
      <div>https://vicasong.github.io/java/upgrade-to-module/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Vica</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月9日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/java/upgrade-to-java17/" title="从Java8升级到Java17">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">从Java8升级到Java17</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/spring-cloud/feign-fallback-proxy/" title="Feign客户端Fallback全局代理">
                        <span class="hidden-mobile">Feign客户端Fallback全局代理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
